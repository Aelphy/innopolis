#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/contrib/contrib.hpp>
#include <iostream>
#include <dirent.h>
#include <unordered_map>

using namespace cv;
using namespace std;

#define TTL 100
#define SIZE_CHANGE 1.1
#define MIN_RECT_SIZE 20

// hash function for rectangle
namespace std {
    template <> struct hash<Rect> {
        std::size_t operator()(const Rect& r) const {
            return r.br().x ^ (r.br().y << 2) ^ (r.tl().x << 4) ^ (r.tl().y << 6);
        }
    };
}

// helper function to check if the value in the rangle
bool value_in_range(int value, int min, int max) {
    return (value >= min) && (value <= max);
}

// check if two rectangles overlap and the difference in their size is not very big
bool is_intersect(Rect r1, Rect r2) {
    bool x_overlap = value_in_range(r1.x, r2.x, r2.x + r2.width) || value_in_range(r2.x, r1.x, r1.x + r1.width);

    bool y_overlap = value_in_range(r1.y, r2.y, r2.y + r2.height) || value_in_range(r2.y, r1.y, r1.y + r1.height);

    bool size_changed = max(r1.width * r1.height, r2.width * r2.height) / (float) min(r1.width * r1.height, r2.width * r2.height) > SIZE_CHANGE;

    return x_overlap && y_overlap && !size_changed;
}

int main() {
    // reading files variables
    DIR *dir;
    string images_dir = "/Users/aelphy/Documents/innopolis/cv/hw4/ObjectAbandonmentAndRemoval/";
    vector <string> videos;
    dir = opendir(images_dir.c_str());
    struct dirent *ent;

    Ptr<BackgroundSubtractor> pMOG2;

    // read the data
    if (dir != NULL) {
        while ((ent = readdir(dir)) != NULL) {
            if (ent->d_name[0] != '.') {
                videos.push_back(ent->d_name);
            }
        }

        closedir (dir);
    } else {
        cout << "not present" << endl;
        return -1;
    }

    // for each video
    for (int i = 0; i < videos.size(); i++) {
        //fg mask fg mask generated by MOG2 method
        Mat fgMaskMOG2;
        Mat fgMaskMOG2_gray;
        Mat frame;
        Mat frame_gray;
        unordered_map <Rect, int> previous_counturs;
        unordered_map <Rect, int> previous_losts;

        VideoCapture cap(images_dir + videos[i]);

        // MOG2 approach
        pMOG2 = new BackgroundSubtractorMOG2(500, 30, true);

        // if not success, exit program
        if (!cap.isOpened()) {
            cout << "Cannot open the video file" << endl;
            exit(EXIT_FAILURE);
        }

        // for each frame
        while(true) {
            // read a new frame from video
            bool is_success = cap.read(frame);

            //if not success, break the loop
            if (!is_success) {
                cout << "Cannot read the frame from video file" << endl;
                break;
            }

            vector < vector <Point> > contours;
            vector < Vec4i > hierarchy;
            unordered_map <Rect, bool> bound_rectangles;

            // frame preprocessing
            cvtColor(frame, frame_gray, CV_BGR2GRAY);
            equalizeHist(frame_gray, frame_gray);
            GaussianBlur(frame_gray, frame_gray, Size(5, 5), 0);

            // not the first two frames
            if (cap.get(CV_CAP_PROP_POS_FRAMES) > 2) {
                // background preprocessing
                equalizeHist(fgMaskMOG2, fgMaskMOG2_gray);
                GaussianBlur(fgMaskMOG2_gray, fgMaskMOG2_gray, Size(9, 9), 0);
                threshold(fgMaskMOG2_gray, fgMaskMOG2_gray, 250, 255, CV_THRESH_BINARY);
                imshow("FG Mask MOG 2 gray", fgMaskMOG2_gray);

                findContours(fgMaskMOG2_gray, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, Point(0, 0));

                vector < vector <Point> > contours_poly(contours.size());

                // find border rectangles
                for (int j = 0; j < contours.size(); j++) {
                    approxPolyDP(Mat(contours[j]), contours_poly[j], 3, true);
                    Rect bound_rectangle = boundingRect(Mat(contours_poly[j]));

                    // reject small counturs
                    if (bound_rectangle.size().height * bound_rectangle.size().width >= MIN_RECT_SIZE * MIN_RECT_SIZE) {
                        bound_rectangles[bound_rectangle] = false;
                    }
                }

                vector <Rect> to_insert;
                vector <int> freqs;

                // for each countur from previous frame
                for (auto it = previous_counturs.begin(); it != previous_counturs.end(); ++it) {
                    bool found = false;

                    rectangle(frame, it->first, Scalar(255, 0, 0));

                    // for each countour from current frame
                    for (auto it2 = bound_rectangles.begin(); it2 != bound_rectangles.end(); ++it2) {
                        // if contours intersect
                        if (is_intersect(it2->first, it->first)) {
                            found = true;

                            // mark rectangle as recognized
                            bound_rectangles[it2->first] = true;
                            rectangle(frame, it2->first, Scalar(255, 255, 0));

                            // mark new rectangle to change the old one
                            to_insert.push_back(it2->first);
                            freqs.push_back(it->second + 1);

                            // if rectangle is old enough
                            if (previous_counturs[it->first] > TTL) {
                                rectangle(frame, it2->first, Scalar(0, 255, 0));
                                rectangle(frame, it->first, Scalar(0, 0, 255));

                                // if the first time for rectangle
                                if (previous_counturs[it->first] == TTL + 1) {
                                    cout << "new object at frame: " << cap.get(CV_CAP_PROP_POS_FRAMES) - (TTL + 1) << endl;
                                }
                            }

                            previous_losts.erase(it->first);

                            break;
                        }
                    }

                    // if rectangle is deleted and old enough - say
                    if (!found && it->second > TTL) {
                        // check if rectangle already exists at losts
                        if (previous_losts.find(it->first) == previous_losts.end()) {
                            previous_losts[it->first] = 0;
                        }

                        previous_losts[it->first] += 1;
                    }
                }

                previous_counturs.clear();

                vector <Rect> to_delete;

                // for every lost rectangle
                for (auto it = previous_losts.begin(); it != previous_losts.end(); ++it) {
                    // if it is not on the 5 frames simultaniously
                    if (it->second > 5) {
                        to_delete.push_back(it->first);
                        cout << "lost object at frame: " << cap.get(CV_CAP_PROP_POS_FRAMES) - (TTL + 5) << endl;
                    } else {
                        previous_counturs[it->first] = TTL + 2;
                        rectangle(frame, it->first, Scalar(0, 255, 255));
                    }
                }

                for (int j = 0; j < to_delete.size(); ++j) {
                    previous_losts.erase(to_delete[j]);
                }

                for (int j = 0; j < to_insert.size(); ++j) {
                    // check if to_insert[j] is already in previous_counturs
                    if (previous_counturs.find(to_insert[j]) != previous_counturs.end()) {
                        previous_counturs[to_insert[j]] = max(previous_counturs[to_insert[j]], freqs[j]);
                    } else {
                        previous_counturs[to_insert[j]] = freqs[j];
                    }
                }

                // add not matched rectangles as new if they don't exist
                for (auto it = bound_rectangles.begin(); it != bound_rectangles.end(); ++it) {
                    if (!it->second && previous_counturs.find(it->first) == previous_counturs.end()) {
                        previous_counturs[it->first] = 0;
                    }
                }
            }

            //update the background model
            pMOG2->operator()(frame_gray, fgMaskMOG2);

            //show the current frame and the fg masks
            imshow("video", frame);
            imshow("FG Mask MOG 2", fgMaskMOG2);

            //wait for 'esc' key press for 30 ms. If 'esc' key is pressed, break loop
            if(waitKey(1) == 27) {
                cout << "esc key is pressed by user" << endl;
                break;
            }
        }
    }

    return 0;
}