#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/contrib/contrib.hpp>
#include <iostream>
#include <dirent.h>

using namespace cv;
using namespace std;

int main() {
    DIR *dir;
    string images_dir = "/Users/aelphy/Documents/innopolis/cv/hw4/ObjectAbandonmentAndRemoval/";
    vector <string> videos;
    dir = opendir(images_dir.c_str());
    struct dirent *ent;

    Ptr<BackgroundSubtractor> pMOG2;

    // read the data
    if (dir != NULL) {
        while ((ent = readdir(dir)) != NULL) {
            if (ent->d_name[0] != '.') {
                videos.push_back(ent->d_name);
            }
        }

        closedir (dir);
    } else {
        cout << "not present" << endl;
        return -1;
    }

    for (int i = videos.size() - 1; i >= 0; i--) {
        VideoCapture cap(images_dir + videos[i]);
        Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
        Mat fgMaskMOG2_gray;
        Mat frame;
        Mat frame_gray;

        pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

        // if not success, exit program
        if (!cap.isOpened()) {
            cout << "Cannot open the video file" << endl;
            exit(EXIT_FAILURE);
        }

        while(true) {
            // read a new frame from video
            bool is_success = cap.read(frame);

            //if not success, break the loop
            if (!is_success) {
                cout << "Cannot read the frame from video file" << endl;
                break;
            }

            vector < vector <Point> > contours;
            vector < Vec4i > hierarchy;

            // frame preprocessing
            cvtColor(frame, frame_gray, CV_BGR2GRAY);
            equalizeHist(frame_gray, frame_gray);
            GaussianBlur(frame_gray, frame_gray, Size(5, 5), 0);

            if (cap.get(CV_CAP_PROP_POS_FRAMES) > 2) {
                equalizeHist(fgMaskMOG2, fgMaskMOG2_gray);
                GaussianBlur(fgMaskMOG2_gray, fgMaskMOG2_gray, Size(5, 5), 0);
                threshold(fgMaskMOG2_gray, fgMaskMOG2_gray, 250, 255, CV_THRESH_BINARY);
                imshow("FG Mask MOG 2 gray", fgMaskMOG2_gray);

                findContours(fgMaskMOG2_gray, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, Point(0, 0));

                vector < vector <Point> > contours_poly(contours.size());
                vector < Rect > bound_rectangles(contours.size());

                // find border rectangles
                for (int j = 0; j < contours.size(); j++) {
                    approxPolyDP(Mat(contours[j]), contours_poly[j], 3, true);
                    bound_rectangles[j] = boundingRect(Mat(contours_poly[j]));
                    drawContours(frame, contours_poly, j, Scalar(0, 255, 0), 1, 8, vector<Vec4i>(), 0, Point() );
                }
            }

            //update the background model
            pMOG2->operator()(frame_gray, fgMaskMOG2);

            //show the current frame and the fg masks
            imshow("video", frame);
            imshow("FG Mask MOG 2", fgMaskMOG2);

            //wait for 'esc' key press for 30 ms. If 'esc' key is pressed, break loop
            if(waitKey(30) == 27) {
                cout << "esc key is pressed by user" << endl;
                break;
            }
        }
    }

    return 0;
}